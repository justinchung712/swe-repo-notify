import time
import sqlite3
import pytest
from fastapi.testclient import TestClient

from persistence.db import init_db
from persistence.repositories import UserRepository
from common.models import UserPreferences

# Import the app and helpers to override
import api.server as srv
from api.security import make_token


class FakeSender:

    def __init__(self):
        self.emails = []
        self.sms = []

    def send_email(self, to_addr, subject, html_body, text_body):
        self.emails.append((to_addr, subject, text_body))

    def send_sms(self, to_number, text_body):
        self.sms.append((to_number, text_body))


@pytest.fixture(autouse=True)
def set_env(monkeypatch):
    # Make sure we have deterministic secrets/base URL in tests
    monkeypatch.setenv("APP_SECRET", "test-secret")
    monkeypatch.setenv("APP_BASE_URL", "http://testserver")
    # Keep default DB path unused; override repo with in-memory DB below


@pytest.fixture
def conn():
    # In-memory DB per test
    conn = sqlite3.connect(":memory:", check_same_thread=False)
    conn.row_factory = sqlite3.Row
    init_db(conn)
    yield conn
    conn.close()


@pytest.fixture
def app_client(conn, monkeypatch):
    # Override the repo dependency to use in-memory DB
    def get_user_repo_override():
        return UserRepository(conn)

    srv.app.dependency_overrides[srv.get_user_repo] = get_user_repo_override

    # Swap out notifier sender with a fake so we don't print to stdout
    fake_sender = FakeSender()
    srv.notifier.sender = fake_sender

    # Capture tokens generated by the app without scraping stdout
    captured = {"verify": [], "edit": []}

    def send_verify(email, phone, uid):
        token = make_token({"purpose": "verify", "uid": uid})
        captured["verify"].append((uid, token))
        # Simulate sending but just store in fake sender
        link = f"http://testserver/verify?token={token}"
        if email:
            fake_sender.send_email(email, "Verify your subscription", link,
                                   link)
        if phone:
            fake_sender.send_sms(phone, link)

    def send_edit(email, phone, uid):
        token = make_token({"purpose": "edit", "uid": uid})
        captured["edit"].append((uid, token))
        link = f"http://testserver/edit?token={token}"
        if email:
            fake_sender.send_email(email, "Edit your notification preferences",
                                   link, link)
        if phone:
            fake_sender.send_sms(phone, link)

    monkeypatch.setattr(srv, "_send_verify_link", send_verify)
    monkeypatch.setattr(srv, "_send_edit_link", send_edit)

    client = TestClient(srv.app)
    # Return client + helpers we want to assert on
    return client, fake_sender, captured, UserRepository(conn)


def test_health(app_client):
    client, _, _, _ = app_client
    r = client.get("/health")
    assert r.status_code == 200
    assert r.json() == {"ok": True}


def test_docs_open(app_client):
    client, *_ = app_client
    r = client.get("/docs")
    assert r.status_code == 200


def test_subscribe_and_verify_and_edit_flow(app_client):
    client, fake_sender, captured, user_repo = app_client

    # 1) Subscribe with email + prefs
    payload = {
        "email": "a@b.com",
        "phone": None,
        "notify_email": True,
        "notify_sms": False,
        "prefs": {
            "subscribe_new_grad": True,
            "subscribe_internship": False,
            "receive_all": True,
            "tech_keywords": [],
            "role_keywords": [],
            "location_keywords": []
        }
    }
    r = client.post("/subscribe", json=payload)
    assert r.status_code == 200
    assert r.json()["status"] == "verification_sent"

    # Email was "sent" with a verify link; token captured
    assert len(fake_sender.emails) == 1
    assert "Verify" in fake_sender.emails[0][1]

    assert captured["verify"], "verify token not captured"
    uid, verify_token = captured["verify"][0]

    # 2) Verify
    r = client.get("/verify", params={"token": verify_token})
    assert r.status_code == 200
    assert r.json()["status"] == "verified"

    # Confirm DB state: user is verified and notify flags persisted
    row = user_repo.get_user(uid)
    assert row is not None
    assert row["is_verified"] == 1
    assert row["notify_email"] == 1
    assert row["notify_sms"] == 0

    # 3) Request edit link
    r = client.post("/request-edit-link", json={"email": "a@b.com"})
    assert r.status_code == 200
    assert r.json()["status"] == "sent"
    assert captured["edit"], "edit token not captured"
    _, edit_token = captured["edit"][0]

    # 4) Update prefs via edit token
    new_prefs = {
        "token": edit_token,
        "subscribe_new_grad": False,
        "subscribe_internship": True,
        "receive_all": False,
        "tech_keywords": ["kubernetes"],
        "role_keywords": ["backend"],
        "location_keywords": ["remote"]
    }
    r = client.post("/update-prefs", json=new_prefs)
    assert r.status_code == 200
    assert r.json()["status"] == "updated"

    # Confirm DB state updated
    got = user_repo.get_user(uid)
    assert got["prefs"].subscribe_internship is True
    assert got["prefs"].subscribe_new_grad is False
    assert got["prefs"].tech_keywords == ["kubernetes"]
    assert got["prefs"].role_keywords == ["backend"]
    assert got["prefs"].location_keywords == ["remote"]


def test_request_edit_link_unknown_user_returns_sent(app_client):
    client, fake_sender, captured, _ = app_client
    r = client.post("/request-edit-link", json={"email": "nouser@example.com"})
    # Don't reveal if user exists; should still be 200 "sent"
    assert r.status_code == 200
    assert r.json()["status"] == "sent"
    # But since user doesn't exist/verified, didn't actually queue any email
    # (Override doesn't simulate sending for unknowns.)


def test_unsubscribe_form_and_confirm(app_client):
    client, fake_sender, captured, user_repo = app_client

    # Subscribe + verify
    payload = {
        "email": "x@y.com",
        "notify_email": True,
        "notify_sms": True,
        "prefs": {
            "subscribe_new_grad": True,
            "subscribe_internship": False,
            "receive_all": True,
            "tech_keywords": [],
            "role_keywords": [],
            "location_keywords": []
        }
    }
    r = client.post("/subscribe", json=payload)
    assert r.status_code == 200
    uid, verify_token = captured["verify"][0]
    client.get("/verify", params={"token": verify_token})

    # Build unsubscribe token
    from api.security import make_token
    token = make_token({"purpose": "unsubscribe", "uid": uid})

    # GET form
    r = client.get("/unsubscribe", params={"token": token})
    assert r.status_code == 200
    assert "Unsubscribe" in r.text

    # POST confirm: disable email only, keep sms on
    body = {"token": token, "disable_email": True, "disable_sms": False}
    r = client.post("/unsubscribe/confirm", json=body)
    assert r.status_code == 200
    assert r.json()["status"] == "unsubscribed"

    row = user_repo.get_user(uid)
    assert row["notify_email"] == 0
    assert row["notify_sms"] == 1


def test_unsubscribe_token_expiry(app_client, monkeypatch, user_repo=None):
    """
    Monkeypatch UNSUB_TTL to be very short, generate a token, wait, and ensure it 400s.
    """
    client, fake_sender, captured, user_repo = app_client

    # Seed a verified user
    prefs = UserPreferences(True, False, True, [], [], [])
    user_repo.create_user(
        user_id="u_exp",
        email="exp@example.com",
        phone=None,
        is_verified=True,
        prefs=prefs,
        notify_email=True,
        notify_sms=False,
    )

    # Token valid for ~1 second
    monkeypatch.setattr(srv, "UNSUB_TTL", 1)

    token = make_token({"purpose": "unsubscribe", "uid": "u_exp"})
    # Let it expire
    time.sleep(2.0)

    r = client.get("/unsubscribe", params={"token": token})
    assert r.status_code == 400
    assert "Token error" in r.text


def test_subscribe_preserves_verified_state(app_client):
    """
    When an existing verified user calls /subscribe (e.g., to update prefs),
    keep is_verified=1 and do NOT send a new verify email.
    """
    client, fake_sender, captured, user_repo = app_client

    # Create a verified user directly in the repo
    prefs = UserPreferences(True, False, True, [], [], [])
    user_repo.create_user(
        user_id="u_preserve",
        email="keep@verified.com",
        phone=None,
        is_verified=True,
        prefs=prefs,
        notify_email=True,
        notify_sms=False,
    )

    # Call /subscribe to "update" their settings (flip a flag to show it updates)
    r = client.post(
        "/subscribe",
        json={
            "email": "keep@verified.com",
            "phone": None,
            "notify_email": True,
            "notify_sms": True,  # Change something
            "prefs": {
                "subscribe_new_grad": False,
                "subscribe_internship": True,
                "receive_all": True,
                "tech_keywords": [],
                "role_keywords": [],
                "location_keywords": []
            }
        })
    assert r.status_code == 200

    # Verify state is preserved and notify flags updated
    row = user_repo.get_user("u_preserve")
    assert row["is_verified"] == 1  # Unchanged
    assert row["notify_email"] == 1  # Still on
    assert row["notify_sms"] == 1  # Updated
    # No verify email should have been sent during this call
    assert captured["verify"] == []
