import os
import sqlite3
import pytest
from fastapi.testclient import TestClient

from persistence.db import init_db
from persistence.repositories import UserRepository
from common.models import UserPreferences, UserContact

# Import the app and helpers to override
import api.server as srv
from api.security import make_token


class FakeSender:

    def __init__(self):
        self.emails = []
        self.sms = []

    def send_email(self, to_addr, subject, html_body, text_body):
        self.emails.append((to_addr, subject, text_body))

    def send_sms(self, to_number, text_body):
        self.sms.append((to_number, text_body))


@pytest.fixture(autouse=True)
def set_env(monkeypatch):
    # Make sure we have deterministic secrets/base URL in tests
    monkeypatch.setenv("APP_SECRET", "test-secret")
    monkeypatch.setenv("APP_BASE_URL", "http://testserver")
    # Keep default DB path unused; override repo with in-memory DB below


@pytest.fixture
def conn():
    # In-memory DB per test
    conn = sqlite3.connect(":memory:", check_same_thread=False)
    conn.row_factory = sqlite3.Row
    init_db(conn)
    yield conn
    conn.close()


@pytest.fixture
def app_client(conn, monkeypatch):
    # Override the repo dependency to use in-memory DB
    def get_user_repo_override():
        return UserRepository(conn)

    srv.app.dependency_overrides[srv.get_user_repo] = get_user_repo_override

    # Swap out notifier sender with a fake so we don't print to stdout
    fake_sender = FakeSender()
    srv.notifier.sender = fake_sender

    # Capture tokens generated by the app without scraping stdout
    captured = {"verify": [], "edit": []}

    def send_verify(email, phone, uid):
        token = make_token({"purpose": "verify", "uid": uid})
        captured["verify"].append((uid, token))
        # Simulate sending but just store in fake sender
        link = f"http://testserver/verify?token={token}"
        if email:
            fake_sender.send_email(email, "Verify your subscription", link,
                                   link)
        if phone:
            fake_sender.send_sms(phone, link)

    def send_edit(email, phone, uid):
        token = make_token({"purpose": "edit", "uid": uid})
        captured["edit"].append((uid, token))
        link = f"http://testserver/edit?token={token}"
        if email:
            fake_sender.send_email(email, "Edit your notification preferences",
                                   link, link)
        if phone:
            fake_sender.send_sms(phone, link)

    monkeypatch.setattr(srv, "_send_verify_link", send_verify)
    monkeypatch.setattr(srv, "_send_edit_link", send_edit)

    client = TestClient(srv.app)
    # Return client + helpers we want to assert on
    return client, fake_sender, captured, UserRepository(conn)


def test_health(app_client):
    client, _, _, _ = app_client
    r = client.get("/health")
    assert r.status_code == 200
    assert r.json() == {"ok": True}


def test_docs_open(app_client):
    client, *_ = app_client
    r = client.get("/docs")
    assert r.status_code == 200


def test_subscribe_and_verify_and_edit_flow(app_client):
    client, fake_sender, captured, user_repo = app_client

    # 1) Subscribe with email + prefs
    payload = {
        "email": "a@b.com",
        "phone": None,
        "notify_email": True,
        "notify_sms": False,
        "prefs": {
            "subscribe_new_grad": True,
            "subscribe_internship": False,
            "receive_all": True,
            "tech_keywords": [],
            "role_keywords": [],
            "location_keywords": []
        }
    }
    r = client.post("/subscribe", json=payload)
    assert r.status_code == 200
    assert r.json()["status"] == "verification_sent"

    # Email was "sent" with a verify link; token captured
    assert len(fake_sender.emails) == 1
    assert "Verify" in fake_sender.emails[0][1]

    assert captured["verify"], "verify token not captured"
    uid, verify_token = captured["verify"][0]

    # 2) Verify
    r = client.get("/verify", params={"token": verify_token})
    assert r.status_code == 200
    assert r.json()["status"] == "verified"

    # Confirm DB state: user is verified and notify flags persisted
    row = user_repo.get_user(uid)
    assert row is not None
    assert row["is_verified"] == 1
    assert row["notify_email"] == 1
    assert row["notify_sms"] == 0

    # 3) Request edit link
    r = client.post("/request-edit-link", json={"email": "a@b.com"})
    assert r.status_code == 200
    assert r.json()["status"] == "sent"
    assert captured["edit"], "edit token not captured"
    _, edit_token = captured["edit"][0]

    # 4) Update prefs via edit token
    new_prefs = {
        "token": edit_token,
        "subscribe_new_grad": False,
        "subscribe_internship": True,
        "receive_all": False,
        "tech_keywords": ["kubernetes"],
        "role_keywords": ["backend"],
        "location_keywords": ["remote"]
    }
    r = client.post("/update-prefs", json=new_prefs)
    assert r.status_code == 200
    assert r.json()["status"] == "updated"

    # Confirm DB state updated
    got = user_repo.get_user(uid)
    assert got["prefs"].subscribe_internship is True
    assert got["prefs"].subscribe_new_grad is False
    assert got["prefs"].tech_keywords == ["kubernetes"]
    assert got["prefs"].role_keywords == ["backend"]
    assert got["prefs"].location_keywords == ["remote"]


def test_request_edit_link_unknown_user_returns_sent(app_client):
    client, fake_sender, captured, _ = app_client
    r = client.post("/request-edit-link", json={"email": "nouser@example.com"})
    # Don't reveal if user exists; should still be 200 "sent"
    assert r.status_code == 200
    assert r.json()["status"] == "sent"
    # But since user doesn't exist/verified, didn't actually queue any email
    # (Override doesn't simulate sending for unknowns.)
